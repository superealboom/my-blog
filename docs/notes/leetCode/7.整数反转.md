---
title: 7.整数反转
createTime: 2025/02/13 22:08:50
permalink: /leetCode/wnm52ngn/
---
自己解法：

```Java
public int reverse(int x) {
    String str = String.valueOf(x);
    if (str.indexOf("-") >= 0) {
        StringBuffer sb = new StringBuffer(str.substring(1, str.length()));
        return Long.valueOf("-" + sb.reverse().toString()) < Integer.MIN_VALUE ? 0 : Integer.valueOf("-" + sb.toString());
    }
    StringBuffer sb = new StringBuffer(str);
    return Long.valueOf(sb.reverse().toString()) > Integer.MAX_VALUE ? 0 : Integer.valueOf(sb.toString());
}
```


额，实在没啥说的，用StringBuffer做就行，用时28ms。答案解法：

```Java
public int reverse(int x) {
    int result = 0;
    while (x != 0) {
        int pop = x % 10;
        x /= 10;
        if (result > Integer.MAX_VALUE / 10 || (result == Integer.MAX_VALUE / 10 && pop > 7)) return 0;
        if (result < Integer.MIN_VALUE / 10 || (result == Integer.MIN_VALUE / 10 && pop < -8)) return 0;

        result = result * 10 + pop;
    }
    return result;
}
```


答案解法倒是也好理解。

两者的一点区别：StringBuffer的就是先反转完之后，用Long储存，在判断有没有超出。

答案的就是每转一位就判断。

当不满足 Integer.MIN_VALUE < result*10 + pop <Integer.MAX_VALUE 的时候判断为超出。44ms。

也没啥说的，记录一个 Integer.MIN_VALUE 和 Integer.MAX_VALUE 的知识点吧。

```Java
Integer.MAX_VALUE = 2147483647
Integer.MIN_VALUE = -2147483648
Integer.MAX_VALUE + 1 = Integer.MIN_VALUE
Math.abs(Integer.MIN_VALUE) =  Integer.MIN_VALUE
```


对于Stringbuffer方法比手动反转快的原因，之后下去看下Stringbuffer源码，再来记录。

