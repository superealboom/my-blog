---
title: 1.两数之和
createTime: 2025/02/13 22:12:11
permalink: /leetCode/zut89b7e/
---
自己解法：

```Java
public int[] f(int[] nums,int target){
		
		for(int i=0;i<nums.length-1;i++){
            for(int j=i+1;j<nums.length;j++){
                if(nums[i] + nums[j] == target){
                    return new int[]{i,j};
                }
            }
        }
        return null;
	}
```


最佳解法：

```Java
public int[] f(int[] nums,int target){
		
		Map<Integer,Integer> map = new HashMap<Integer,Integer>();
		for(int i=0;i<nums.length;i++){
			if(map.containsKey(target-nums[i])){
				return new int[]{map.get(target-nums[i]), i};
			}
			map.put(nums[i], i);
		}
		return null;
	}
```


我的暴力破解不提也罢...

简单说下最佳解法的思路。

map的<key,value>存的是<数值，下标>，循环遍历下标，把数组每个数按照规则存进去的过程中，会被if判断中断。当target减去当前数值的得数在key中存在时，证明找到了两个数相加等于target的数，遂return。

